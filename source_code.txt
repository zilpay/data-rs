Project Path: data-rs

Source Tree:

```txt
data-rs
└── src
    ├── components
    │   ├── dex.rs
    │   ├── eth_tracker.rs
    │   ├── mod.rs
    │   ├── rates.rs
    │   ├── tokens.rs
    │   └── uniswap.rs
    ├── config
    │   ├── blockchain.rs
    │   ├── currencies.rs
    │   ├── dex.rs
    │   ├── meta.rs
    │   ├── mod.rs
    │   ├── rates.rs
    │   ├── server.rs
    │   └── zilliqa.rs
    ├── lib.rs
    ├── main.rs
    ├── models
    │   ├── currencies.rs
    │   ├── dex.rs
    │   ├── meta.rs
    │   └── mod.rs
    ├── server
    │   ├── mod.rs
    │   └── routers
    │       ├── dex.rs
    │       ├── mod.rs
    │       ├── rates.rs
    │       └── tokens.rs
    └── utils
        ├── crypto.rs
        ├── mod.rs
        └── zilliqa.rs

```

`data-rs/src/components/eth_tracker.rs`:

```rs
use super::{
    tokens::{coingecko_get_tokens, Token},
    uniswap::get_token_prices_in_eth,
};
use bincode::config::{self, Configuration};
use sled;
use std::error::Error;

const ETH_STORAGE_KEY: &[u8] = b"eth_tokens";

pub struct EthTracker {
    db: sled::Db,
    bincode_config: Configuration,
}

impl EthTracker {
    pub fn new() -> Result<Self, Box<dyn Error>> {
        let db = sled::open("data-rs/eth_tracker_db")?;
        let bincode_config = config::standard();

        Ok(EthTracker { db, bincode_config })
    }

    pub fn get_tokens(&self) -> Result<Vec<Token>, Box<dyn Error>> {
        if let Some(encoded) = self.db.get(ETH_STORAGE_KEY)? {
            let (tokens, _): (Vec<Token>, usize) =
                bincode::decode_from_slice(&encoded[..], self.bincode_config).unwrap();

            Ok(tokens)
        } else {
            Ok(vec![])
        }
    }

    pub fn save_tokens(&self, tokens: Vec<Token>) -> Result<(), Box<dyn Error>> {
        let bytes = bincode::encode_to_vec(tokens, self.bincode_config)?;

        self.db.insert(ETH_STORAGE_KEY, bytes)?;
        self.db.flush()?;

        Ok(())
    }

    pub async fn update_tokens_from_coingecko(&self) -> Result<(), Box<dyn Error>> {
        let mut current_tokens = self.get_tokens()?;
        let new_tokens = coingecko_get_tokens("ethereum").await?;
        for new_token in new_tokens {
            if !current_tokens
                .iter()
                .any(|t| t.address == new_token.address)
            {
                current_tokens.push(new_token);
            }
        }
        self.save_tokens(current_tokens)?;
        Ok(())
    }

    pub async fn update_rates_from_uniswap(&self) -> Result<(), Box<dyn Error>> {
        let mut tokens = self.get_tokens()?;
        get_token_prices_in_eth(&mut tokens).await?;
        self.save_tokens(tokens)?;
        Ok(())
    }
}

```

`data-rs/src/components/mod.rs`:

```rs
pub mod dex;
pub mod eth_tracker;
pub mod rates;
pub mod tokens;
pub mod uniswap;

```

`data-rs/src/components/rates.rs`:

```rs
use reqwest::Client;
use serde_json::Value;
use std::collections::HashMap;
use std::env;
use thiserror::Error;

use crate::config::rates::BASE_CURRENCY;

#[derive(Error, Debug)]
pub enum RatesApiError {
    #[error("HTTP request failed: {0}")]
    Reqwest(#[from] reqwest::Error),

    #[error("Invalid API key: {0}")]
    InvalidApiKey(String),

    #[error("API error: {0}")]
    ApiError(String),

    #[error("Missing environment variable: {0}")]
    EnvVar(String),

    #[error("Parse Json response: {0}, response: {1}")]
    ParseResponseError(String, String),
}

pub async fn get_cryptocompare_prices(
    fsyms: &[&str],
) -> Result<HashMap<String, f64>, RatesApiError> {
    let fsyms_str = fsyms.join(",");
    let url = format!(
        "https://min-api.cryptocompare.com/data/pricemulti?fsyms={}&tsyms={}",
        fsyms_str, BASE_CURRENCY
    );
    let client = Client::new();
    let response = client.get(&url).send().await?;
    let body: Value = response.json().await?;

    parse_crypto_response(body)
}

pub async fn get_metals_prices() -> Result<HashMap<String, f64>, RatesApiError> {
    let api_key = env::var("METALS_API_KEY")
        .map_err(|_| RatesApiError::EnvVar("METALS_API_KEY not set".to_string()))?;
    let url = format!(
        "https://api.metals.dev/v1/latest?api_key={}&currency={}&unit=g",
        api_key, BASE_CURRENCY,
    );
    let client = Client::new();
    let response = client.get(&url).send().await?;
    let body: Value = response.json().await?;
    parse_metals_response(body)
}

fn parse_crypto_response(body: Value) -> Result<HashMap<String, f64>, RatesApiError> {
    if body.get("Response") == Some(&Value::String("Error".to_string())) {
        let message = body
            .get("Message")
            .and_then(|m| m.as_str())
            .unwrap_or("Unknown error");
        return Err(RatesApiError::ApiError(message.to_string()));
    }
    let mut result = HashMap::new();
    if let Some(obj) = body.as_object() {
        for (key, value) in obj {
            if let Some(price) = value.get(BASE_CURRENCY).and_then(|v| v.as_f64()) {
                result.insert(key.clone(), price);
            }
        }
    }
    Ok(result)
}

fn parse_metals_response(body: Value) -> Result<HashMap<String, f64>, RatesApiError> {
    if body["status"].as_str() == Some("failure") {
        let error_message = body["error_message"]
            .as_str()
            .unwrap_or("Unknown error")
            .to_string();
        return Err(if body["error_code"].as_i64() == Some(1101) {
            RatesApiError::InvalidApiKey(error_message)
        } else {
            RatesApiError::ApiError(error_message)
        });
    }

    let mut result = HashMap::new();

    let metal_tickers = [
        ("aluminum", "XAL"),
        ("copper", "XCU"),
        ("gold", "XAU"),
        ("lead", "XPB"),
        ("nickel", "XNI"),
        ("palladium", "XPD"),
        ("platinum", "XPT"),
        ("silver", "XAG"),
        ("zinc", "XZN"),
    ];

    if let Some(metals) = body["metals"].as_object() {
        for (key, value) in metals {
            if let Some(ticker) = metal_tickers
                .iter()
                .find(|&&(k, _)| k == key)
                .map(|&(_, t)| t)
            {
                if let Some(price) = value.as_f64() {
                    result.insert(ticker.to_string(), price);
                }
            }
        }
    }

    if let Some(currencies) = body["currencies"].as_object() {
        for (key, value) in currencies {
            if let Some(rate) = value.as_f64() {
                result.insert(key.to_string(), rate);
            }
        }
    }

    Ok(result)
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[tokio::test]
    async fn test_parse_metals_response_success() {
        let mock = json!({
            "currencies": {
                "AED": 1.0,
                "AFN": 0.05211012,
                "SZL": 0.20355583,
                "XCD": 1.35894319,
                "XDR": 4.95522258,
                "XOF": 0.00624893,
                "XPF": 0.03434988,
                "YER": 0.01503309,
                "ZAR": 0.20355583,
                "ZMW": 0.13807739,
                "ZWD": 0.01014782,
                "ZWL": 0.00005463
            },
            "currency": "AED",
            "metals": {
                "aluminum": 0.009,
                "copper": 0.0373,
                "gold": 378.2465,
                "lead": 0.0073,
                "nickel": 0.0571,
                "palladium": 113.3537,
                "platinum": 116.7301,
                "silver": 3.8126,
                "zinc": 0.0099
            },
            "status": "success",
            "timestamps": {
                "currency": "2025-05-17T03:54:19.725Z",
                "metal": "2025-05-17T03:55:03.494Z"
            },
            "unit": "g"
        });

        let res = parse_metals_response(mock).unwrap();

        assert!(res.contains_key("XAU"), "Expected key XAU");
        assert!(res.contains_key("XAG"), "Expected key XAG");
        assert!(res.contains_key("XPT"), "Expected key XPT");
        assert!(res.contains_key("XPD"), "Expected key XPD");
        assert!(res.contains_key("XAL"), "Expected key XAL");
        assert!(res.contains_key("XCU"), "Expected key XCU");
        assert!(res.contains_key("XPB"), "Expected key XPB");
        assert!(res.contains_key("XNI"), "Expected key XNI");
        assert!(res.contains_key("XZN"), "Expected key XZN");

        assert!(res.contains_key("AED"), "Expected key AED");
        assert!(!res.contains_key("USD"), "USD key should not be present");
        assert!(res.contains_key("ZAR"), "Expected key ZAR");

        assert_eq!(res.get("XAU"), Some(&378.2465), "Incorrect value for XAU");
        assert_eq!(res.get("XAG"), Some(&3.8126), "Incorrect value for XAG");
        assert_eq!(res.get("XPT"), Some(&116.7301), "Incorrect value for XPT");
        assert_eq!(res.get("AED"), Some(&1.0), "Incorrect value for AED");
        assert_eq!(res.get("ZAR"), Some(&0.20355583), "Incorrect value for ZAR");

        assert_eq!(
            res.len(),
            21,
            "Expected 21 elements (9 metals + 12 currencies)"
        );

        assert!(
            !res.contains_key("LBMA_XAU_AM"),
            "LBMA_XAU_AM should not be present"
        );
        assert!(
            !res.contains_key("MCX_XAU"),
            "MCX_XAU should not be present"
        );
    }

    #[tokio::test]
    async fn test_parse_metals_response_invalid_api_key() {
        let mock = json!({
            "error_code": 1101,
            "error_message": "Unauthorized. The API Key provided is invalid.",
            "status": "failure"
        });

        let res = parse_metals_response(mock);
        assert!(res.is_err());
        if let Err(RatesApiError::InvalidApiKey(msg)) = res {
            assert_eq!(msg, "Unauthorized. The API Key provided is invalid.");
        } else {
            panic!("Expected InvalidApiKey error");
        }
    }

    #[tokio::test]
    async fn test_parse_metals_response_generic_api_error() {
        let mock = json!({
            "error_code": 9999,
            "error_message": "Unknown API error",
            "status": "failure"
        });

        let res = parse_metals_response(mock);
        assert!(res.is_err());
        if let Err(RatesApiError::ApiError(msg)) = res {
            assert_eq!(msg, "Unknown API error");
        } else {
            panic!("Expected ApiError error");
        }
    }

    #[test]
    fn test_parse_crypto_response() {
        let mut eth_map = serde_json::Map::new();

        eth_map.insert(BASE_CURRENCY.to_string(), json!(0.02406));
        let eth = Value::Object(eth_map);

        let mut zil_map = serde_json::Map::new();
        zil_map.insert(BASE_CURRENCY.to_string(), json!(1.3e-7));
        let zil = Value::Object(zil_map);

        let mut eko_map = serde_json::Map::new();
        eko_map.insert(BASE_CURRENCY.to_string(), json!(1.3e-7));
        let eko = Value::Object(eko_map);

        let mut mock_map = serde_json::Map::new();
        mock_map.insert("ETH".to_string(), eth);
        mock_map.insert("ZIL".to_string(), zil);
        mock_map.insert("EKO".to_string(), eko);
        let mock = Value::Object(mock_map);

        let res = parse_crypto_response(mock).unwrap();
        assert_eq!(res.get("ETH"), Some(&0.02406));
        assert_eq!(res.get("ZIL"), Some(&1.3e-7));
        assert_eq!(res.get("EKO"), Some(&1.3e-7));
    }

    #[tokio::test]
    async fn test_cryptocompare() {
        let tokens = ["BNB", "ETH", "USDT", "USDC", "JPY", "RUB", "EKO"];
        let result = get_cryptocompare_prices(&tokens).await.unwrap();
        for token in tokens {
            assert!(result.contains_key(token), "Expected key {}", token);
        }
    }

    // #[tokio::test]
    // async fn test_coingecko_rates() {
    //     let tokens = ["BNB", "ETH", "USDT", "USDC", "JPY", "RUB", "EKO"];
    //     let result = get_coingecko_prices(&tokens).await.unwrap();
    //     // for token in tokens {
    //     //     assert!(result.contains_key(token), "Expected key {}", token);
    //     // }
    // }
}

```

`data-rs/src/components/tokens.rs`:

```rs
use bincode::{Decode, Encode};
use reqwest::Client;
use serde_json::Value;
use thiserror::Error;

#[derive(Debug, Error, PartialEq, Eq)]
pub enum TokenQuotesError {
    #[error("API request error: {0}")]
    ApiRequestError(String),

    #[error("Response parsing error: {0}, content: {1}")]
    ParseResponseError(String, String),
}

#[derive(Debug, Decode, Encode, Clone)]
pub enum TokenType {
    FT,
    NFT,
}

#[derive(Debug, Decode, Encode, Clone)]
pub enum TokenStatus {
    Available,
    Buned,
}

#[derive(Debug, Decode, Encode, Clone)]
pub struct Token {
    pub address: String,
    pub scope: u64,
    pub name: String,
    pub symbol: String,
    pub token_type: TokenType,
    pub decimals: u8,
    pub listed: bool,
    pub status: TokenStatus,
    pub chain_id: u64,
    pub rate: f64,
    pub last_price: f64,
}

pub type Result<T> = std::result::Result<T, TokenQuotesError>;

pub async fn pancakeswap_get_tokens() -> Result<Vec<Token>> {
    let url = "https://tokens.pancakeswap.finance/pancakeswap-extended.json";

    let client = Client::new();
    let res = client
        .get(url)
        .send()
        .await
        .map_err(|e| TokenQuotesError::ApiRequestError(e.to_string()))?;
    let json: Value = res
        .json()
        .await
        .map_err(|e| TokenQuotesError::ApiRequestError(e.to_string()))?;

    let api_tokens: Vec<serde_json::Value> = json["tokens"]
        .as_array()
        .ok_or_else(|| {
            TokenQuotesError::ParseResponseError(
                "Invalid tokens format".to_string(),
                json.to_string(),
            )
        })?
        .clone();

    let total_length = api_tokens.len() as u64;
    let tokens: Vec<Token> = api_tokens
        .into_iter()
        .enumerate()
        .map(|(index, token)| Token {
            scope: total_length - index as u64,
            chain_id: token["chainId"].as_u64().unwrap_or_default(),
            name: token["name"].as_str().unwrap_or_default().to_string(),
            symbol: token["symbol"].as_str().unwrap_or_default().to_string(),
            decimals: token["decimals"].as_u64().unwrap_or(0) as u8,
            address: token["address"].as_str().unwrap_or_default().to_string(),
            token_type: TokenType::FT,
            listed: true,
            status: TokenStatus::Available,
            rate: 0.0,
            last_price: 0.0,
        })
        .collect();

    Ok(tokens)
}

pub async fn coingecko_get_tokens(chain_name: &str) -> Result<Vec<Token>> {
    let url = format!("https://tokens.coingecko.com/{}/all.json", chain_name);

    let client = Client::new();
    let res = client
        .get(&url)
        .send()
        .await
        .map_err(|e| TokenQuotesError::ApiRequestError(e.to_string()))?;
    let json: Value = res
        .json()
        .await
        .map_err(|e| TokenQuotesError::ApiRequestError(e.to_string()))?;

    let api_tokens: Vec<serde_json::Value> = json["tokens"]
        .as_array()
        .ok_or_else(|| {
            TokenQuotesError::ParseResponseError(
                "Invalid tokens format".to_string(),
                json.to_string(),
            )
        })?
        .clone();

    let total_length = api_tokens.len() as u64;
    let tokens: Vec<Token> = api_tokens
        .into_iter()
        .enumerate()
        .map(|(index, token)| Token {
            scope: total_length - index as u64,
            chain_id: token["chainId"].as_u64().unwrap_or_default(),
            name: token["name"].as_str().unwrap_or_default().to_string(),
            symbol: token["symbol"].as_str().unwrap_or_default().to_string(),
            decimals: token["decimals"].as_u64().unwrap_or(0) as u8,
            address: token["address"].as_str().unwrap_or_default().to_string(),
            token_type: TokenType::FT,
            listed: true,
            status: TokenStatus::Available,
            rate: 0.0,
            last_price: 0.0,
        })
        .collect();

    Ok(tokens)
}

#[cfg(test)]
mod pancakeswap_get_tokens_tests {

    use super::*;
    use tokio;

    #[tokio::test]
    async fn test_get_tokens_bsc() {
        let tokens = pancakeswap_get_tokens().await.unwrap();
        assert!(!tokens.is_empty());
        let token = &tokens[0];
        assert!(!token.name.is_empty());
        assert!(!token.symbol.is_empty());
        assert!(token.decimals > 0);
        assert_eq!(token.scope, tokens.len() as u64);
        assert_eq!(tokens.last().unwrap().scope, 1);
    }

    #[tokio::test]
    async fn test_get_tokens() {
        let tokens = coingecko_get_tokens("base").await.unwrap();
        assert!(!tokens.is_empty());
        let token = &tokens[0];
        assert!(!token.name.is_empty());
        assert!(!token.symbol.is_empty());
        assert!(token.decimals > 0);
        assert_eq!(token.scope, tokens.len() as u64);
        assert_eq!(tokens.last().unwrap().scope, 1);
    }

    #[tokio::test]
    async fn test_get_tokens_chain() {
        let tokens = coingecko_get_tokens("ethereum").await.unwrap();
        assert!(!tokens.is_empty());
        let token = &tokens[0];
        assert!(!token.name.is_empty());
        assert!(!token.symbol.is_empty());
        assert!(token.decimals > 0);
        assert_eq!(token.scope, tokens.len() as u64);
        assert_eq!(tokens.last().unwrap().scope, 1);
    }

    #[tokio::test]
    async fn test_get_tokens_default_values() {
        let tokens = coingecko_get_tokens("tron").await.unwrap();
        assert!(!tokens.is_empty());
        let token = &tokens[0];
        assert!(!token.name.is_empty());
        assert!(!token.symbol.is_empty());
        assert!(token.decimals > 0);
        assert_eq!(token.scope, tokens.len() as u64);
        assert_eq!(tokens.last().unwrap().scope, 1);
    }

    // #[tokio::test]
    // async fn test_update_rates() {
    //     let tokens = pancakeswap_get_tokens().await.unwrap();
    //     let symbols: Vec<&str> = tokens.iter().map(|t| t.symbol.as_str()).collect();

    //     let chunk_size = CRYPTOCOMPARE_TOKENS_LIMIT;
    //     let mut all_rates = HashMap::new();

    //     for chunk in symbols.chunks(chunk_size) {
    //         dbg!(chunk.len());
    //         let rates = get_cryptocompare_prices(chunk).await.unwrap();
    //         all_rates.extend(rates);
    //     }

    //     dbg!(&all_rates);

    //     for symbol in &symbols {
    //         assert!(
    //             all_rates.contains_key(*symbol),
    //             "Missing rate for {}",
    //             symbol
    //         );
    //     }
    // }
}

```

`data-rs/src/components/uniswap.rs`:

```rs
use std::time::Duration;

use alloy::{
    primitives::{address, Address, U256},
    sol,
    sol_types::SolCall,
};
use reqwest::Client;
use serde_json::json;
use thiserror::Error;

use super::tokens::Token;

pub const URLS: [&str; 5] = [
    "https://cloudflare-eth.com",
    "https://eth.llamarpc.com",
    "https://eth.rpc.blxrbdn.com",
    "https://virginia.rpc.blxrbdn.com",
    "https://rpc.flashbots.net",
];
const WETH_ADDRESS: Address = address!("0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2");
const FACTORY_ADDRESS: Address = address!("0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f");

sol! {
    #[sol(rpc)]
    contract IUniswapV2Factory {
        function getPair(address tokenA, address tokenB) external view returns (address pair);
    }
}

sol! {
    #[sol(rpc)]
    contract IUniswapV2Pair {
        function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
        function token0() external view returns (address);
    }
}

#[derive(Error, Debug)]
pub enum UniswapDexError {
    #[error("HTTP request failed: {0}")]
    Reqwest(#[from] reqwest::Error),

    #[error("API error: {0}")]
    ApiError(String),

    #[error("Missing environment variable: {0}")]
    EnvVar(String),
}

fn create_eth_call_request(id: String, to: Address, data: Vec<u8>) -> serde_json::Value {
    json!({
        "jsonrpc": "2.0",
        "id": id,
        "method": "eth_call",
        "params": [
            {
                "to": alloy::hex::encode_prefixed(to),
                "data": alloy::hex::encode_prefixed(data)
            },
            "latest"
        ]
    })
}

async fn send_batch_request(
    client: &Client,
    urls: &[&str],
    requests: &[serde_json::Value],
) -> Result<Vec<serde_json::Value>, UniswapDexError> {
    for url in urls {
        match client.post(*url).json(requests).send().await {
            Ok(response) => {
                if response.status().is_success() {
                    let responses: Vec<serde_json::Value> =
                        response.json().await.map_err(UniswapDexError::Reqwest)?;
                    if responses.iter().all(|r| r.get("result").is_some()) {
                        return Ok(responses);
                    }
                }
            }
            Err(_e) => {}
        }
    }
    Err(UniswapDexError::ApiError(
        "All nodes failed or returned errors".to_string(),
    ))
}

pub async fn get_token_prices_in_eth(tokens: &mut [Token]) -> Result<(), UniswapDexError> {
    let client = Client::builder().timeout(Duration::from_secs(10)).build()?;

    let mut batch_requests = Vec::with_capacity(tokens.len());
    for (i, token) in tokens.iter().enumerate() {
        let get_pair_call = IUniswapV2Factory::getPairCall {
            tokenA: token.address.parse().unwrap_or_default(),
            tokenB: WETH_ADDRESS,
        };
        let data = get_pair_call.abi_encode();
        let request = create_eth_call_request(format!("getPair_{}", i), FACTORY_ADDRESS, data);
        batch_requests.push(request);
    }

    let responses = send_batch_request(&client, &URLS, &batch_requests).await?;

    let mut pair_addresses = vec![Address::ZERO; tokens.len()];
    for resp in responses {
        if let Some(id) = resp["id"].as_str() {
            if let Some(result) = resp["result"].as_str() {
                if let Some(index) = id
                    .strip_prefix("getPair_")
                    .and_then(|s| s.parse::<usize>().ok())
                {
                    let data = alloy::hex::decode(&result[2..]).map_err(|e| {
                        UniswapDexError::ApiError(format!("Hex decode error: {}", e))
                    })?;
                    let decoded = IUniswapV2Factory::getPairCall::abi_decode_returns(&data)
                        .map_err(|e| {
                            UniswapDexError::ApiError(format!("ABI decode error: {}", e))
                        })?;
                    pair_addresses[index] = decoded;
                }
            }
        }
    }

    let mut batch_requests_2 = Vec::new();
    for (i, &pair_address) in pair_addresses.iter().enumerate() {
        if pair_address != Address::ZERO {
            let get_reserves_call = IUniswapV2Pair::getReservesCall {};
            let data_reserves = get_reserves_call.abi_encode();
            let request_reserves =
                create_eth_call_request(format!("getReserves_{}", i), pair_address, data_reserves);
            batch_requests_2.push(request_reserves);

            let token0_call = IUniswapV2Pair::token0Call {};
            let data_token0 = token0_call.abi_encode();
            let request_token0 =
                create_eth_call_request(format!("token0_{}", i), pair_address, data_token0);
            batch_requests_2.push(request_token0);
        }
    }

    let responses_2 = send_batch_request(&client, &URLS, &batch_requests_2).await?;

    let mut reserves = vec![None; tokens.len()];
    let mut token0s = vec![None; tokens.len()];
    for resp in responses_2 {
        if let Some(id) = resp["id"].as_str() {
            if let Some(result) = resp["result"].as_str() {
                let data = alloy::hex::decode(&result[2..])
                    .map_err(|e| UniswapDexError::ApiError(format!("Hex decode error: {}", e)))?;
                if let Some(index) = id
                    .strip_prefix("getReserves_")
                    .and_then(|s| s.parse::<usize>().ok())
                {
                    let decoded = IUniswapV2Pair::getReservesCall::abi_decode_returns(&data)
                        .map_err(|e| {
                            UniswapDexError::ApiError(format!("ABI decode error: {}", e))
                        })?;
                    reserves[index] = Some((decoded.reserve0, decoded.reserve1));
                } else if let Some(index) = id
                    .strip_prefix("token0_")
                    .and_then(|s| s.parse::<usize>().ok())
                {
                    let decoded =
                        IUniswapV2Pair::token0Call::abi_decode_returns(&data).map_err(|e| {
                            UniswapDexError::ApiError(format!("ABI decode error: {}", e))
                        })?;
                    token0s[index] = Some(decoded);
                }
            }
        }
    }

    for i in 0..tokens.len() {
        if let (Some((reserve0, reserve1)), Some(token0_address)) = (reserves[i], token0s[i]) {
            let token_address = &tokens[i].address;
            let (reserve_token, reserve_weth) = if token_address == &token0_address.to_string() {
                (U256::from(reserve0), U256::from(reserve1))
            } else {
                (U256::from(reserve1), U256::from(reserve0))
            };

            if reserve_token != U256::ZERO {
                let reserve_weth_eth = f64::from(reserve_weth) / 1e18;
                let reserve_token_tokens =
                    f64::from(reserve_token) / 10f64.powi(tokens[i].decimals as i32);
                let new_rate = reserve_weth_eth / reserve_token_tokens;

                tokens[i].last_price = tokens[i].rate;
                tokens[i].rate = new_rate;
            }
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::components::tokens::{TokenStatus, TokenType};

    #[tokio::test]
    async fn test_get_token_prices_in_eth() {
        let mut tokens = vec![
            Token {
                address: "0x6B175474E89094C44Da98b954EedeAC495271d0F".to_string(), // DAI
                scope: 0,
                name: "Dai Stablecoin".to_string(),
                symbol: "DAI".to_string(),
                token_type: TokenType::FT,
                decimals: 18,
                listed: true,
                status: TokenStatus::Available,
                chain_id: 1,
                rate: 0.0,
                last_price: 0.0,
            },
            Token {
                address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48".to_string(), // USDC
                scope: 0,
                name: "USD Coin".to_string(),
                symbol: "USDC".to_string(),
                token_type: TokenType::FT,
                decimals: 6,
                listed: true,
                status: TokenStatus::Available,
                chain_id: 1,
                rate: 0.0,
                last_price: 0.0,
            },
            Token {
                address: "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599".to_string(), // USDC
                scope: 0,
                name: "Wrapped Bitcoin".to_string(),
                symbol: "WBTC".to_string(),
                token_type: TokenType::FT,
                decimals: 8,
                listed: true,
                status: TokenStatus::Available,
                chain_id: 1,
                rate: 0.0,
                last_price: 0.0,
            },
        ];

        get_token_prices_in_eth(&mut tokens)
            .await
            .expect("Failed to fetch token prices");

        assert!(tokens[0].rate > 0.0, "DAI price should be positive");
        assert!(tokens[1].rate > 0.0, "USDC price should be positive");
        assert!(tokens[2].rate > 0.0, "WBTC price should be positive");
    }
}

```

`data-rs/src/config/blockchain.rs`:

```rs
pub const BLOCKCHAIN_KEY: &str = "BLOCKCHAIN";
pub const BLOCK_NUMBER_KEY: &str = "BLOCK_NUMBER";
pub const START_INDEX_BLOCK: u64 = 2188355;
pub const BLOCK_LIMIT: usize = 100;

```

`data-rs/src/config/currencies.rs`:

```rs
pub const CURRENCIES: [&str; 140] = [
    "USD", "JPY", "CNY", "CHF", "CAD", "MXN", "INR", "BRL", "RUB", "KRW", "IDR", "TRY", "SAR",
    "SEK", "NGN", "PLN", "ARS", "NOK", "TWD", "IRR", "AED", "COP", "THB", "ZAR", "DKK", "MYR",
    "SGD", "ILS", "HKD", "EGP", "PHP", "CLP", "PKR", "IQD", "DZD", "KZT", "QAR", "CZK", "PEN",
    "RON", "VND", "BDT", "HUF", "UAH", "AOA", "MAD", "OMR", "CUC", "BYR", "AZN", "LKR", "SDG",
    "SYP", "MMK", "DOP", "UZS", "KES", "GTQ", "URY", "HRV", "MOP", "ETB", "CRC", "TZS", "TMT",
    "TND", "PAB", "LBP", "RSD", "LYD", "GHS", "YER", "BOB", "BHD", "CDF", "PYG", "UGX", "SVC",
    "TTD", "AFN", "NPR", "HNL", "BIH", "BND", "ISK", "KHR", "GEL", "MZN", "BWP", "PGK", "JMD",
    "XAF", "NAD", "ALL", "SSP", "MUR", "MNT", "NIO", "LAK", "MKD", "AMD", "MGA", "XPF", "TJS",
    "HTG", "BSD", "MDL", "RWF", "KGS", "GNF", "SRD", "SLL", "XOF", "MWK", "FJD", "ERN", "SZL",
    "GYD", "BIF", "KYD", "MVR", "LSL", "LRD", "CVE", "DJF", "SCR", "SOS", "GMD", "KMF", "STD",
    "BTC", "XRP", "AUD", "BGN", "JOD", "GBP", "ETH", "EUR", "LTC", "NZD",
];
pub const CURRENCIES_KEY: &str = "RATES";

```

`data-rs/src/config/dex.rs`:

```rs
pub const DEX: &str = "459cb2d3baf7e61cfbd5fe362f289ae92b2babb0";
pub const DEX_KEY: &str = "DEX";

```

`data-rs/src/config/meta.rs`:

```rs
pub const TOKENS_EXCEPTIONS: [[&str; 2]; 2] = [
    [
        "zil1cuf78e3p37utekgk0gtcvd3hvkrqcgt06lrnty",
        "zil1n02sfv2ytldc7jnyx3f7c9zehwdzlxy2ykrhf9",
    ],
    [
        "zil180v66mlw007ltdv8tq5t240y7upwgf7djklmwh",
        "zil1zu72vac254htqpg3mtywdcfm84l3dfd9qzww8t",
    ],
];
pub const MIN_SCORE: u8 = 5;
pub const CRYPTO_META_URL: &str =
    "https://raw.githubusercontent.com/ViewBlock/cryptometa/master/src/full.json";
pub const META_KEY: &str = "META";

```

`data-rs/src/config/mod.rs`:

```rs
pub mod blockchain;
pub mod currencies;
pub mod dex;
pub mod meta;
pub mod rates;
pub mod server;
pub mod zilliqa;

```

`data-rs/src/config/rates.rs`:

```rs
pub const BASE_CURRENCY: &str = "AED";
pub const API_URL_COINGECKO: &str = "https://api.coingecko.com/api/v3/simple/price";
pub const CRYPTOCOMPARE_TOKENS_LIMIT: usize = 50;

```

`data-rs/src/config/zilliqa.rs`:

```rs
pub const PROVIDERS: [&str; 3] = [
    "https://api.zilliqa.com",
    "https://ssn.zilpay.io/api",
    "https://zilliqa.avely.fi/api",
];
pub const CHARSET: &str = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
pub const ZERO_ADDR: &str = "0000000000000000000000000000000000000000";
pub const HRP: &str = "zil";
pub struct RPCMethod {
    // Network-related methods
    pub get_network_id: &'static str,

    // Blockchain-related methods
    pub get_blockchain_info: &'static str,
    pub get_sharding_structure: &'static str,
    pub get_ds_block: &'static str,
    pub get_latest_ds_block: &'static str,
    pub get_num_ds_blocks: &'static str,
    pub get_ds_block_rate: &'static str,
    pub ds_block_listing: &'static str,
    pub get_tx_block: &'static str,
    pub get_latest_tx_block: &'static str,
    pub get_num_tx_blocks: &'static str,
    pub get_tx_block_rate: &'static str,
    pub tx_block_listing: &'static str,
    pub get_num_transactions: &'static str,
    pub get_transaction_rate: &'static str,
    pub get_current_mini_epoch: &'static str,
    pub get_current_ds_epoch: &'static str,
    pub get_prev_difficulty: &'static str,
    pub get_prev_ds_difficulty: &'static str,
    pub get_total_coin_supply: &'static str,
    pub get_miner_info: &'static str,

    // Transaction-related methods
    pub create_transaction: &'static str,
    pub get_transaction: &'static str,
    pub get_transaction_status: &'static str,
    pub get_recent_transactions: &'static str,
    pub get_transactions_for_tx_block: &'static str,
    pub get_transactions_for_tx_block_ex: &'static str,
    pub get_txn_bodies_for_tx_block: &'static str,
    pub get_txn_bodies_for_tx_block_ex: &'static str,
    pub get_num_txns_tx_epoch: &'static str,
    pub get_num_txns_ds_epoch: &'static str,
    pub get_minimum_gas_price: &'static str,

    // Contract-related methods
    pub get_contract_address_from_transaction_id: &'static str,
    pub get_smart_contracts: &'static str,
    pub get_smart_contract_code: &'static str,
    pub get_smart_contract_init: &'static str,
    pub get_smart_contract_state: &'static str,
    pub get_smart_contract_sub_state: &'static str,
    pub get_state_proof: &'static str,

    // Account-related methods
    pub get_balance: &'static str,
}

pub const RPC_METHODS: RPCMethod = RPCMethod {
    // Network-related methods
    get_network_id: "GetNetworkId",

    // Blockchain-related methods
    get_blockchain_info: "GetBlockchainInfo",
    get_sharding_structure: "GetShardingStructure",
    get_ds_block: "GetDsBlock",
    get_latest_ds_block: "GetLatestDsBlock",
    get_num_ds_blocks: "GetNumDSBlocks",
    get_ds_block_rate: "GetDSBlockRate",
    ds_block_listing: "DSBlockListing",
    get_tx_block: "GetTxBlock",
    get_latest_tx_block: "GetLatestTxBlock",
    get_num_tx_blocks: "GetNumTxBlocks",
    get_tx_block_rate: "GetTxBlockRate",
    tx_block_listing: "TxBlockListing",
    get_num_transactions: "GetNumTransactions",
    get_transaction_rate: "GetTransactionRate",
    get_current_mini_epoch: "GetCurrentMiniEpoch",
    get_current_ds_epoch: "GetCurrentDSEpoch",
    get_prev_difficulty: "GetPrevDifficulty",
    get_prev_ds_difficulty: "GetPrevDSDifficulty",
    get_total_coin_supply: "GetTotalCoinSupply",
    get_miner_info: "GetMinerInfo",

    // Transaction-related methods
    create_transaction: "CreateTransaction",
    get_transaction: "GetTransaction",
    get_transaction_status: "GetTransactionStatus",
    get_recent_transactions: "GetRecentTransactions",
    get_transactions_for_tx_block: "GetTransactionsForTxBlock",
    get_transactions_for_tx_block_ex: "GetTransactionsForTxBlockEx",
    get_txn_bodies_for_tx_block: "GetTxnBodiesForTxBlock",
    get_txn_bodies_for_tx_block_ex: "GetTxnBodiesForTxBlockEx",
    get_num_txns_tx_epoch: "GetNumTxnsTxEpoch",
    get_num_txns_ds_epoch: "GetNumTxnsDSEpoch",
    get_minimum_gas_price: "GetMinimumGasPrice",

    // Contract-related methods
    get_contract_address_from_transaction_id: "GetContractAddressFromTransactionID",
    get_smart_contracts: "GetSmartContracts",
    get_smart_contract_code: "GetSmartContractCode",
    get_smart_contract_init: "GetSmartContractInit",
    get_smart_contract_state: "GetSmartContractState",
    get_smart_contract_sub_state: "GetSmartContractSubState",
    get_state_proof: "GetStateProof",

    // Account-related methods
    get_balance: "GetBalance",
};

```

`data-rs/src/lib.rs`:

```rs
pub mod components;
pub mod config;
pub mod models;
pub mod server;
pub mod utils;

```

`data-rs/src/main.rs`:

```rs
use data_rs::{
    models::{currencies::Currencies, dex::Dex, meta::Meta},
    server::run_server,
    utils::zilliqa::Zilliqa,
};
use log::{error, LevelFilter};
use simple_logger::SimpleLogger;
use std::{sync::Arc, time::Duration};
use tokio;
use tokio::sync::RwLock;

#[tokio::main]
async fn main() {
    SimpleLogger::new()
        .with_colors(true)
        .with_level(LevelFilter::Info)
        .init()
        .unwrap();

    let db_path = std::env::var("DB_PATH").expect("Incorrect DB_PATH env var");
    let port: u16 = std::env::var("PORT")
        .expect("ENV var PORT is required")
        .parse()
        .expect("ENV var PORT should be u16 number");

    let meta = Arc::new(RwLock::new(Meta::new(&db_path)));
    let rates = Arc::new(RwLock::new(Currencies::new(&db_path)));
    let dex = Arc::new(RwLock::new(Dex::new(&db_path)));

    let meta_ref = Arc::clone(&meta);
    let dex_ref = Arc::clone(&dex);
    let meta_dex_ref = Arc::clone(&dex);
    let rates_ref = Arc::clone(&rates);

    // tokio::task::spawn(async move {
    //     loop {
    //         tokio::time::sleep(Duration::from_secs(50)).await;

    //         let zil = Zilliqa::new();
    //         let tokens = match Meta::get_meta_tokens().await {
    //             Ok(tokens) => tokens,
    //             Err(e) => {
    //                 error!("github:meta: {:?}", e);

    //                 continue;
    //             }
    //         };

    //         let sorted = match Meta::sort_zilliqa_tokens(&tokens, &zil).await {
    //             Ok(sorted) => sorted,
    //             Err(e) => {
    //                 error!("zilliqa node: {:?}", e);

    //                 continue;
    //             }
    //         };

    //         let mut unwarp_meta = meta_ref.write().await;

    //         match unwarp_meta.update(tokens, sorted) {
    //             Ok(_) => {
    //                 let dex = meta_dex_ref.read().await;

    //                 unwarp_meta.listed_tokens_update(&dex);
    //                 unwarp_meta.write_db().unwrap(); // TODO: make Error hanlder.
    //             }
    //             Err(e) => {
    //                 error!("tokens update: {:?}", e);

    //                 continue;
    //             }
    //         };
    //     }
    // });

    tokio::task::spawn(async move {
        loop {
            tokio::time::sleep(Duration::from_secs(20)).await;

            match Currencies::fetch_rates().await {
                Ok(rates) => {
                    rates_ref.write().await.update(rates).unwrap();
                }
                Err(e) => {
                    error!("fetch rates error: {:?}", e);
                }
            };
        }
    });

    tokio::task::spawn(async move {
        loop {
            tokio::time::sleep(Duration::from_secs(20)).await;

            let zil = Zilliqa::new();
            match Dex::get_pools(&zil).await {
                Ok(pools) => {
                    dex_ref.write().await.update(pools).unwrap();
                }
                Err(e) => {
                    error!("fetch rates error: {:?}", e);
                }
            };
        }
    });

    let meta_ref0 = Arc::clone(&meta);
    let dex_ref0 = Arc::clone(&dex);
    let rates_ref0 = Arc::clone(&rates);

    run_server(&meta_ref0, &dex_ref0, &rates_ref0, port)
        .await
        .unwrap();
}

```

`data-rs/src/models/currencies.rs`:

```rs
use std::io::{Error, ErrorKind};

use crate::config::currencies::{CURRENCIES, CURRENCIES_KEY};
use log::{error, info};
use reqwest::Client;
use serde::Deserialize;
use serde_json::{Map, Value};
use sled::{Db, IVec};

#[derive(Debug)]
pub struct Currencies {
    pub data: Map<String, Value>,
    db: Db,
    app_name: &'static str,
}

#[derive(Deserialize, Debug)]
struct APIResponse {
    zilliqa: Map<String, Value>,
}

impl Currencies {
    pub fn new(db_path: &str) -> Self {
        let app_name = "RATES";
        let db = sled::open(format!("{}/{}", db_path, CURRENCIES_KEY))
            .expect("Cannot open currencies database.");
        let data = match db.get(CURRENCIES_KEY) {
            Ok(mb_cache) => {
                let cache = mb_cache.unwrap_or(IVec::default());
                let mb_json = std::str::from_utf8(&cache).unwrap_or("{}");

                serde_json::from_str(mb_json).unwrap_or(Map::new())
            }
            Err(_) => {
                let mut data = Map::new();

                for currency in CURRENCIES {
                    data.insert(currency.to_lowercase().to_owned(), Value::from(0.0));
                }

                data
            }
        };

        Currencies { data, db, app_name }
    }

    pub fn serializatio(&self) -> String {
        serde_json::to_string(&self.data).unwrap()
    }

    pub fn update(&mut self, rates: Map<String, Value>) -> Result<(), Error> {
        self.data = rates;
        self.db
            .insert(CURRENCIES_KEY, self.serializatio().as_bytes())?;

        info!("{:?}: rates updated!", self.app_name);

        Ok(())
    }

    pub async fn fetch_rates() -> Result<Map<String, Value>, Error> {
        let data = match Currencies::coingecko().await {
            Ok(data) => data,
            Err(e) => {
                let custom_error = Error::new(ErrorKind::Other, "coingecko is down");

                error!("coingecko: cannot load rates, error: {:?}", e);

                return Err(custom_error);
            }
        };

        Ok(data)
    }

    async fn coingecko() -> Result<Map<String, Value>, reqwest::Error> {
        let client = Client::new();
        let url = format!(
            "https://api.coingecko.com/api/v3/simple/price?ids=zilliqa&vs_currencies={}",
            CURRENCIES.join(",")
        )
        .to_lowercase();
        let response = client.get(url).send().await?;

        let body: APIResponse = response.json().await?;

        Ok(body.zilliqa)
    }
}

```

`data-rs/src/models/dex.rs`:

```rs
use log::{error, info};
use serde::Deserialize;
use serde_json::json;
use sled::{Db, IVec};
use std::collections::HashMap;
use std::io::{Error, ErrorKind};
use std::u128;

use crate::{
    config::{
        dex::{DEX, DEX_KEY},
        zilliqa::RPC_METHODS,
    },
    utils::zilliqa::{JsonBodyReq, JsonBodyRes, Zilliqa},
};

#[derive(Debug)]
pub struct Dex {
    pub pools: HashMap<String, (u128, u128)>,
    db: Db,
    app_name: &'static str,
}

#[derive(Debug, Deserialize)]
struct Pool {
    arguments: (String, String),
}

#[derive(Debug, Deserialize)]
struct ResPoolState {
    pools: HashMap<String, Pool>,
}

impl Dex {
    pub fn new(db_path: &str) -> Self {
        let app_name = "DEX";
        let db = sled::open(format!("{}/{}", db_path, DEX_KEY)).expect("Cannot dex open database.");
        let pools: HashMap<String, (u128, u128)> = match db.get(DEX_KEY) {
            Ok(mb_cache) => {
                let cache = mb_cache.unwrap_or(IVec::default());
                let mb_json = std::str::from_utf8(&cache).unwrap();
                let pools = serde_json::from_str(mb_json).unwrap_or(HashMap::new());

                info!("{app_name}: loaded from cache {}", pools.len());

                pools
            }
            Err(_) => {
                error!("{app_name}: fail to load cache!");

                HashMap::new()
            }
        };

        Dex {
            db,
            pools,
            app_name,
        }
    }

    pub fn update(&mut self, pools: HashMap<String, (u128, u128)>) -> Result<(), Error> {
        self.pools = pools;
        self.db.insert(DEX_KEY, self.serializatio().as_bytes())?;

        info!("{:?}: updated pools {:?}", self.app_name, self.pools.len());

        Ok(())
    }

    pub async fn get_pools(zilliqa: &Zilliqa) -> Result<HashMap<String, (u128, u128)>, Error> {
        let pools = Dex::fetch(zilliqa).await?;

        Ok(pools)
    }

    pub fn serializatio(&self) -> String {
        serde_json::to_string(&self.pools).unwrap()
    }

    async fn fetch(zilliqa: &Zilliqa) -> Result<HashMap<String, (u128, u128)>, Error> {
        let field = "pools";
        let custom_error = Error::new(ErrorKind::Other, "Fail to fetch or parse response");
        let params = json!([DEX, field, []]);
        let bodies: Vec<JsonBodyReq> =
            vec![zilliqa.build_body(RPC_METHODS.get_smart_contract_sub_state, params)];
        let res: Vec<JsonBodyRes<ResPoolState>> = zilliqa.fetch(bodies).await?;
        let pools = match res.get(0) {
            Some(res) => match &res.result {
                Some(result) => &result.pools,
                None => return Err(custom_error),
            },
            None => {
                return Err(custom_error);
            }
        };
        let pools: HashMap<String, (u128, u128)> = pools
            .into_iter()
            .filter_map(|(key, value)| {
                let key = key.to_string();
                let zils: u128 = value.arguments.0.parse().unwrap();
                let tokens: u128 = value.arguments.1.parse().unwrap();
                let args = (zils, tokens);

                if zils == 0 || tokens == 0 {
                    return None;
                }

                Some((key, args))
            })
            .collect();

        Ok(pools)
    }
}

```

`data-rs/src/models/meta.rs`:

```rs
use std::u8;

use crate::{
    config::{
        meta::{CRYPTO_META_URL, META_KEY, MIN_SCORE, TOKENS_EXCEPTIONS},
        zilliqa::RPC_METHODS,
    },
    utils::{
        crypto::from_bech32_address,
        zilliqa::{JsonBodyReq, JsonBodyRes, Zilliqa},
    },
};
use log::{error, info};
use reqwest::Client;
use serde::{Deserialize, Serialize};
use serde_json::{json, Map, Value};
use sled::Db;
use std::{
    collections::HashSet,
    io::{Error, ErrorKind},
};

use super::dex::Dex;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Token {
    pub bech32: String,
    pub base16: String,
    pub scope: u8,
    pub name: String,
    pub symbol: String,
    pub token_type: u8,
    pub decimals: u8,
    pub listed: bool,
    pub status: u8,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct ContractInit {
    #[serde(flatten)]
    pub value: serde_json::Value,
    pub vname: String,

    #[serde(rename = "type")]
    pub field_type: String,
}

#[derive(Debug)]
pub struct Meta {
    pub list: Vec<Token>,
    db: Db,
    app_name: &'static str,
}

impl Meta {
    pub fn new(db_path: &str) -> Self {
        let app_name = "META";
        let db =
            sled::open(format!("{}/{}", db_path, META_KEY)).expect("Cannot meta open database.");

        let list = db
            .get(META_KEY)
            .map(|mb_cache| {
                let cache = mb_cache.unwrap_or_default();
                std::str::from_utf8(&cache)
                    .map(|mb_json| serde_json::from_str(mb_json).unwrap_or_default())
                    .unwrap_or_default()
            })
            .unwrap_or_else(|_| {
                error!("{app_name}: fail to load cache!");
                Vec::new()
            });

        info!("{app_name}: loaded from cache {}", list.len());
        Meta { list, db, app_name }
    }

    pub fn update(
        &mut self,
        tokens: Vec<(String, u8, String)>,
        res: Vec<JsonBodyRes<Vec<ContractInit>>>,
    ) -> Result<(), std::io::Error> {
        let existing_base16s: HashSet<String> =
            self.list.iter().map(|t| t.base16.to_lowercase()).collect();

        let new_tokens: Vec<Token> = res
            .iter()
            .filter_map(|r| {
                let params = r.result.as_ref()?;
                let (name, symbol, base16, decimals) = Meta::parse_init(params).ok()?;

                if existing_base16s.contains(&base16.to_lowercase()) {
                    return None;
                }

                let (bech32, scope, _) = tokens
                    .iter()
                    .find(|(_, _, b16)| {
                        b16.to_lowercase().replace("0x", "")
                            == base16.replace("0x", "").to_lowercase()
                    })?
                    .clone();

                Some(Token {
                    bech32,
                    status: 1,
                    base16,
                    decimals,
                    name,
                    symbol,
                    token_type: 1,
                    scope,
                    listed: false,
                })
            })
            .collect();

        info!("{}: added new tokens {}", self.app_name, new_tokens.len());

        self.list.extend(new_tokens);
        self.write_db()?;

        Ok(())
    }

    pub fn write_db(&mut self) -> Result<(), Error> {
        self.list.sort_by(|a, b| b.scope.cmp(&a.scope));
        self.db.insert(META_KEY, self.serialization().as_bytes())?;
        Ok(())
    }

    pub async fn sort_zilliqa_tokens(
        tokens: &Vec<(String, u8, String)>,
        zilliqa: &Zilliqa,
    ) -> Result<Vec<JsonBodyRes<Vec<ContractInit>>>, Error> {
        let bodies: Vec<JsonBodyReq> = tokens
            .iter()
            .map(|(_, _, base16)| {
                zilliqa.build_body(RPC_METHODS.get_smart_contract_init, json!([base16]))
            })
            .collect();

        let results = zilliqa.fetch::<Vec<ContractInit>>(bodies).await?;
        Ok(results)
    }

    pub async fn get_meta_tokens() -> Result<Vec<(String, u8, String)>, Error> {
        Meta::fetch().await.map_err(|e| {
            error!("Github is down!, error: {:?}", e);
            Error::new(ErrorKind::Other, "Github is down")
        })
    }

    pub fn listed_tokens_update(&mut self, dex: &Dex) {
        for token in &mut self.list {
            token.listed = dex.pools.contains_key(&token.base16);
        }
    }

    pub fn serialization(&self) -> String {
        serde_json::to_string(&self.list).unwrap_or_default()
    }

    async fn fetch() -> Result<Vec<(String, u8, String)>, reqwest::Error> {
        let client = Client::new();
        let response = client.get(CRYPTO_META_URL).send().await?;
        let chain = "zilliqa.";
        let body: Map<String, Value> = response.json().await?;

        let body: Vec<(String, u8, String)> = body
            .into_iter()
            .filter_map(|(key, value)| {
                if !key.contains(chain) {
                    return None;
                }

                let bech32 = key.replace(chain, "");
                let base16 = from_bech32_address(&bech32).map(hex::encode)?;

                let found_exceptions = TOKENS_EXCEPTIONS.iter().find(|&addr| addr[0] == bech32);
                let score: u8 = value
                    .get("gen")
                    .and_then(|gen| gen.get("score"))
                    .and_then(|s| s.as_u64())
                    .map(|s| s as u8)
                    .unwrap_or(0);

                if score < MIN_SCORE {
                    return None;
                }

                match found_exceptions {
                    Some(found) => from_bech32_address(&found[1])
                        .map(|addr| (String::from(found[1]), score, hex::encode(addr))),
                    None => Some((bech32, score, base16)),
                }
            })
            .collect();

        Ok(body)
    }

    fn parse_init(params: &Vec<ContractInit>) -> Result<(String, String, String, u8), Error> {
        let get_string_value = |vname: &str| -> Result<String, Error> {
            params
                .iter()
                .find(|item| item.vname == vname)
                .and_then(|n| n.value.get("value"))
                .and_then(|v| v.as_str())
                .map(|s| s.to_string())
                .ok_or_else(|| {
                    Error::new(ErrorKind::Other, format!("vname ({}) is required", vname))
                })
        };

        let name = get_string_value("name")?;
        let symbol = get_string_value("symbol")?;
        let base16 = get_string_value("_this_address")?.to_lowercase();

        let decimals = params
            .iter()
            .find(|item| item.vname == "decimals")
            .and_then(|n| n.value.get("value"))
            .and_then(|v| v.as_str())
            .map(|s| s.parse::<u8>().unwrap_or(0))
            .ok_or_else(|| Error::new(ErrorKind::Other, "vname (decimals) is required"))?;

        Ok((name, symbol, base16, decimals))
    }
}

```

`data-rs/src/models/mod.rs`:

```rs
pub mod currencies;
pub mod dex;
pub mod meta;

```

`data-rs/src/server/mod.rs`:

```rs
use hyper::service::service_fn;
use hyper_util::rt::TokioIo;
use hyper_util::server::conn::auto;
use log::{error, info};
use std::{io, net::SocketAddr, sync::Arc};
use tokio::net::TcpListener;
use tokio::sync::RwLock;

use routers::route;

use crate::models::{currencies::Currencies, dex::Dex, meta::Meta};

mod routers;

pub async fn run_server(
    meta: &Arc<RwLock<Meta>>,
    dex: &Arc<RwLock<Dex>>,
    rates: &Arc<RwLock<Currencies>>,
    port: u16,
) -> Result<(), io::Error> {
    let addr = SocketAddr::from(([127, 0, 0, 1], port));
    let listener = TcpListener::bind(&addr).await?;

    info!("Listening on http://{}", addr);

    loop {
        let (stream, _) = listener.accept().await?;
        let meta_ref = Arc::clone(&meta);
        let dex_ref = Arc::clone(&dex);
        let rates_ref = Arc::clone(&rates);

        tokio::task::spawn(async move {
            let service = service_fn(move |req| {
                route(req, meta_ref.clone(), dex_ref.clone(), rates_ref.clone())
            });

            let io = TokioIo::new(stream);

            if let Err(err) = auto::Builder::new(hyper_util::rt::TokioExecutor::new())
                .serve_connection(io, service)
                .await
            {
                error!("Failed to serve connection: {:?}", err);
            }
        });
    }
}

```

`data-rs/src/server/routers/dex.rs`:

```rs
use bytes::Bytes;
use http_body_util::Full;
use hyper::{header, Request, Response};
use serde::Serialize;
use serde_json::{self, json};
use std::{collections::HashMap, sync::Arc};
use tokio::sync::RwLock;

use crate::models::{
    currencies::Currencies,
    dex::Dex,
    meta::{Meta, Token},
};

#[derive(Debug, Serialize)]
pub struct ListedTokens {
    pub count: usize,
    pub list: Vec<Token>,
}

#[derive(Debug, Serialize)]
struct DexResponse {
    tokens: ListedTokens,
    pools: HashMap<String, (String, String)>,
    rate: String,
}

pub async fn handle_get_pools(
    _req: Request<hyper::body::Incoming>,
    meta: Arc<RwLock<Meta>>,
    dex: Arc<RwLock<Dex>>,
    rates: Arc<RwLock<Currencies>>,
) -> Result<Response<Full<Bytes>>, hyper::Error> {
    let mut tokens: Vec<Token> = Vec::new();
    let mut pools: HashMap<String, (String, String)> = HashMap::new();
    let rate = rates
        .read()
        .await
        .data
        .get("usd")
        .unwrap_or(&json!("0"))
        .to_string();
    let zilliqa = Token {
        bech32: String::from("zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz"),
        base16: String::from("0x0000000000000000000000000000000000000000"),
        decimals: 12,
        symbol: String::from("ZIL"),
        name: String::from("Zilliqa"),
        token_type: 1,
        status: 1,
        scope: 100,
        listed: true,
    };

    tokens.push(zilliqa);

    for token in meta.read().await.list.iter() {
        if token.listed && token.token_type == 1 && token.status == 1 {
            tokens.push(token.clone());
        }
    }

    for (key, values) in dex.read().await.pools.iter() {
        pools.insert(
            key.to_string(),
            (values.0.to_string(), values.1.to_string()),
        );
    }

    let tokens_res = ListedTokens {
        count: tokens.len(),
        list: tokens,
    };
    let response = DexResponse {
        rate,
        pools,
        tokens: tokens_res,
    };
    let json_str = serde_json::to_string(&response).unwrap();
    let response = Response::builder()
        .header(header::CONTENT_TYPE, "application/json")
        .body(Full::new(Bytes::from(json_str)))
        .unwrap();

    Ok(response)
}

```

`data-rs/src/server/routers/mod.rs`:

```rs
use bytes::Bytes;
use http_body_util::Full;
use hyper::StatusCode;
use hyper::{Request, Response};
use std::sync::Arc;
use tokio::sync::RwLock;

use crate::models::{currencies::Currencies, dex::Dex, meta::Meta};

mod dex;
mod rates;
mod tokens;

pub async fn route(
    req: Request<hyper::body::Incoming>,
    meta: Arc<RwLock<Meta>>,
    dex: Arc<RwLock<Dex>>,
    rates: Arc<RwLock<Currencies>>,
) -> Result<Response<Full<Bytes>>, hyper::Error> {
    match (req.method(), req.uri().path()) {
        (&hyper::Method::GET, "/api/v1/dex") => dex::handle_get_pools(req, meta, dex, rates).await,
        (&hyper::Method::GET, "/api/v1/rates") => rates::handle_get_rates(req, rates).await,
        (&hyper::Method::GET, "/api/v1/tokens") => tokens::handle_get_tokens(req, meta).await,
        (&hyper::Method::GET, path) if path.starts_with("/api/v1/token/") => {
            tokens::handle_get_token(req, meta).await
        }
        (&hyper::Method::PUT, path) if path.starts_with("/api/v1/token/") => {
            tokens::handle_update_token(req, meta).await
        }
        _ => Ok(Response::builder()
            .status(StatusCode::NOT_FOUND)
            .body(Full::new(Bytes::from("Not Found")))
            .unwrap()),
    }
}

```

`data-rs/src/server/routers/rates.rs`:

```rs
use bytes::Bytes;
use http_body_util::Full;
use hyper::{
    header::{self, ACCESS_CONTROL_ALLOW_METHODS, ACCESS_CONTROL_ALLOW_ORIGIN},
    http::HeaderValue,
    Request, Response,
};
use std::sync::Arc;
use tokio::sync::RwLock;

use crate::models::currencies::Currencies;

pub async fn handle_get_rates(
    _req: Request<hyper::body::Incoming>,
    rates: Arc<RwLock<Currencies>>,
) -> Result<Response<Full<Bytes>>, hyper::Error> {
    // TODO: add currency query.
    let json = rates.read().await.serializatio();
    let mut response = Response::builder()
        .header(header::CONTENT_TYPE, "application/json")
        .body(Full::new(Bytes::from(json)))
        .unwrap();

    response
        .headers_mut()
        .insert(ACCESS_CONTROL_ALLOW_ORIGIN, HeaderValue::from_static("*"));
    response.headers_mut().insert(
        ACCESS_CONTROL_ALLOW_METHODS,
        HeaderValue::from_static("GET"),
    );

    Ok(response)
}

```

`data-rs/src/server/routers/tokens.rs`:

```rs
use crate::models::meta::Meta;
use crate::models::meta::Token;
use bytes::Bytes;
use http_body_util::BodyExt;
use http_body_util::Full;
use hyper::header::ACCESS_CONTROL_ALLOW_METHODS;
use hyper::header::ACCESS_CONTROL_ALLOW_ORIGIN;
use hyper::http::HeaderValue;
use hyper::{header, Request, Response, StatusCode};
use serde_json::Value;
use serde_json::{self, json};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;

use super::dex::ListedTokens;

pub async fn handle_get_tokens(
    req: Request<hyper::body::Incoming>,
    meta: Arc<RwLock<Meta>>,
) -> Result<Response<Full<Bytes>>, hyper::Error> {
    let mut tokens: Vec<Token> = Vec::new();
    let mut params_map = HashMap::new();
    let query_params = req.uri().query().unwrap_or("");
    let parsed_params = url::form_urlencoded::parse(query_params.as_bytes());

    for (key, value) in parsed_params {
        params_map.insert(key.into_owned(), value.into_owned());
    }

    let limit: usize = params_map
        .get("limit")
        .unwrap_or(&"200".to_string())
        .parse()
        .unwrap_or(200);
    let token_type: u8 = params_map
        .get("type")
        .unwrap_or(&"1".to_string())
        .parse()
        .unwrap_or(1);
    let offset: usize = params_map
        .get("offset")
        .unwrap_or(&"0".to_string())
        .parse()
        .unwrap_or(0);

    for token in meta.read().await.list.iter() {
        if token.token_type == token_type && token.status == 1 {
            tokens.push(token.clone());
        }
    }

    let tokens = tokens
        .into_iter()
        .skip(offset)
        .take(limit)
        .collect::<Vec<Token>>();
    let tokens_res = ListedTokens {
        count: tokens.len(),
        list: tokens,
    };

    let res_json = serde_json::to_string(&tokens_res).unwrap();
    let mut response = Response::builder()
        .header(header::CONTENT_TYPE, "application/json")
        .body(Full::new(Bytes::from(res_json)))
        .unwrap();

    response
        .headers_mut()
        .insert(ACCESS_CONTROL_ALLOW_ORIGIN, HeaderValue::from_static("*"));
    response.headers_mut().insert(
        ACCESS_CONTROL_ALLOW_METHODS,
        HeaderValue::from_static("GET"),
    );

    Ok(response)
}

pub async fn handle_get_token(
    req: Request<hyper::body::Incoming>,
    meta: Arc<RwLock<Meta>>,
) -> Result<Response<Full<Bytes>>, hyper::Error> {
    let params = req.uri().path().split("/").collect::<Vec<&str>>();
    let symbol = params.last().unwrap_or(&"").to_lowercase();

    if let Some(token) = meta
        .read()
        .await
        .list
        .iter()
        .find(|t| t.symbol.to_lowercase() == symbol && t.status == 1)
    {
        let res_json = serde_json::to_string(&token).unwrap();
        let response = Response::builder()
            .header(header::CONTENT_TYPE, "application/json")
            .body(Full::new(Bytes::from(res_json)))
            .unwrap();

        Ok(response)
    } else {
        let res = json!({
            "code": -1,
            "message": format!("No token {}", symbol)
        });
        let not_found = serde_json::to_string(&res).unwrap();
        let response = Response::builder()
            .header(header::CONTENT_TYPE, "application/json")
            .status(StatusCode::NOT_FOUND)
            .body(Full::new(Bytes::from(not_found)))
            .unwrap();

        Ok(response)
    }
}

pub async fn handle_update_token(
    req: Request<hyper::body::Incoming>,
    meta: Arc<RwLock<Meta>>,
) -> Result<Response<Full<Bytes>>, hyper::Error> {
    let access_token = std::env::var("ACCESS_TOKEN").unwrap_or("666".to_string());
    let header_token = match req.headers().get("Authorization") {
        Some(value) => value.to_str().unwrap_or(""),
        None => "",
    };
    let response = Response::builder().header(header::CONTENT_TYPE, "application/json");

    if access_token != header_token {
        let res = json!({
            "code": -5,
            "message": format!("Incorrect atuh token {header_token}")
        });
        let res_json = serde_json::to_string(&res).unwrap();
        let response = response
            .status(StatusCode::NETWORK_AUTHENTICATION_REQUIRED)
            .body(Full::new(Bytes::from(res_json)))
            .unwrap();

        return Ok(response);
    }

    let params = req.uri().path().split("/").collect::<Vec<&str>>();
    let base16 = params.last().unwrap_or(&"").to_lowercase();
    let body_bytes = req.collect().await?.to_bytes();
    let value: Value = match serde_json::from_slice(&body_bytes) {
        Ok(v) => v,
        Err(_) => {
            let res = json!({
                "code": -2,
                "message": "Incorrect params"
            });
            let res_json = serde_json::to_string(&res).unwrap();
            let response = response
                .status(StatusCode::BAD_REQUEST)
                .body(Full::new(Bytes::from(res_json)))
                .unwrap();

            return Ok(response);
        }
    };
    let map = match value.as_object() {
        Some(v) => v,
        None => {
            let res = json!({
                "code": -2,
                "message": "Incorrect params"
            });
            let res_json = serde_json::to_string(&res).unwrap();
            let response = response
                .status(StatusCode::BAD_REQUEST)
                .body(Full::new(Bytes::from(res_json)))
                .unwrap();

            return Ok(response);
        }
    };
    let status = map.get("status");
    let score = map.get("score");
    let listed = map.get("listed");
    let symbol = map.get("symbol");
    let mut token_meta = meta.write().await;
    let token_index = match token_meta
        .list
        .iter()
        .position(|t| t.base16.to_lowercase() == base16)
    {
        Some(index) => index,
        None => {
            let res = json!({
                "code": -1,
                "message": format!("No token {}", base16)
            });
            let not_found = serde_json::to_string(&res).unwrap();
            let response = response
                .status(StatusCode::NOT_FOUND)
                .body(Full::new(Bytes::from(not_found)))
                .unwrap();

            return Ok(response);
        }
    };

    if let Some(status) = status {
        let new_status = status.as_u64().unwrap_or(0);
        let new_status: u8 = if new_status > 1 { 1 } else { new_status as u8 };

        token_meta.list[token_index].status = new_status;
    }
    if let Some(symbol) = symbol {
        let new_symbol = symbol.as_str().unwrap_or("").to_string();

        token_meta.list[token_index].symbol = new_symbol;
    }
    if let Some(score) = score {
        let new_score: u8 = score.as_u64().unwrap_or(0) as u8;

        token_meta.list[token_index].scope = new_score;
    }
    if let Some(listed) = listed {
        let new_listed = listed.as_bool().unwrap_or(false);

        token_meta.list[token_index].listed = new_listed;
    }

    match token_meta.write_db() {
        Ok(_) => (),
        Err(_) => {
            let res = json!({
                "code": -4,
                "message": "Cannot write database"
            });
            let wr_db = serde_json::to_string(&res).unwrap();
            let response = response
                .status(StatusCode::BAD_REQUEST)
                .body(Full::new(Bytes::from(wr_db)))
                .unwrap();

            return Ok(response);
        }
    };

    let res = json!({ "message": format!("updated token {}", base16) });
    let ok = serde_json::to_string(&res).unwrap();
    let response = response
        .status(StatusCode::OK)
        .body(Full::new(Bytes::from(ok)))
        .unwrap();

    return Ok(response);
}

```

`data-rs/src/utils/crypto.rs`:

```rs
use crate::config::zilliqa::{CHARSET, HRP};
use sha2::{Digest, Sha256};
use std::io::{Error, ErrorKind};

pub const GENERATOR: [u32; 5] = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];

pub fn polymod(values: &[u8]) -> u32 {
    let mut chk: u32 = 1;

    for p in values {
        let top = chk >> 25;

        chk = ((chk & 0x1ffffff) << 5) ^ (*p as u32);

        for i in 0..5 {
            if ((top >> i) & 1) == 1 {
                chk ^= GENERATOR[i];
            }
        }
    }

    chk
}

pub fn gen_limited_vec(start: u64, end: u64, limit: usize) -> Vec<u64> {
    let mut list = Vec::with_capacity(limit);

    for i in start..end {
        if list.len() >= limit {
            break;
        }

        list.push(i);
    }

    list
}

pub fn hrp_expand(hrp: &str) -> Vec<u8> {
    let mut ret = Vec::new();

    for p in 0..hrp.len() {
        ret.push(hrp.as_bytes()[p] >> 5);
    }

    ret.push(0);

    for p in 0..hrp.len() {
        ret.push(hrp.as_bytes()[p] & 31);
    }

    ret
}

pub fn create_checksum(hrp: &str, data: &Vec<u8>) -> Vec<u8> {
    let mut values: Vec<u8> = Vec::new();

    values.extend(hrp_expand(hrp));
    values.extend(data);
    values.extend(vec![0; 6]);

    let polymod = polymod(&values) ^ 1;
    let mut ret = Vec::new();

    for p in 0..6 {
        ret.push(((polymod >> (5 * (5 - p))) & 31) as u8);
    }

    ret
}

pub fn verify_checksum(hrp: &str, data: &Vec<u8>) -> bool {
    let values = [&hrp_expand(hrp)[..], data].concat();

    polymod(&values) == 1
}

pub fn decode(bech_string: &str) -> Option<(String, Vec<u8>)> {
    let mut has_lower = false;
    let mut has_upper = false;

    for c in bech_string.chars() {
        let code = c as u32;
        if code < 33 || code > 126 {
            return None;
        }
        if code >= 97 && code <= 122 {
            has_lower = true;
        }
        if code >= 65 && code <= 90 {
            has_upper = true;
        }
    }

    if has_lower && has_upper {
        return None;
    }

    let bech_string = bech_string.to_lowercase();
    let pos = bech_string.rfind('1').unwrap_or(0);

    if pos < 1 || pos + 7 > bech_string.len() || bech_string.len() > 90 {
        return None;
    }

    let hrp = bech_string[..pos].to_string();
    let mut data = Vec::new();

    for c in bech_string[pos + 1..].chars() {
        let d = CHARSET.find(c).unwrap_or(0);
        data.push(d as u8);
    }

    if !verify_checksum(&hrp, &data) {
        return None;
    }

    Some((hrp, data[..data.len() - 6].to_vec()))
}

pub fn encode(hrp: &str, data: &Vec<u8>) -> String {
    let checksum = create_checksum(hrp, data);
    let combined = [&data[..], &checksum[..]].concat();
    let mut ret = String::from(hrp) + "1"; // hrp is zil so it is zil1.

    for p in 0..combined.len() {
        let idx = combined[p] as usize;
        let value = CHARSET.chars().nth(idx);

        match value {
            Some(v) => ret.push(v),
            None => continue,
        }
    }

    ret
}

pub fn get_address_from_public_key(public_key: &str) -> Result<String, Error> {
    let normalized = match hex::decode(public_key.to_lowercase().replace("0x", "")) {
        Ok(h) => h,
        Err(_) => {
            let pub_key_err = Error::new(ErrorKind::Other, "Invalid pub_key");

            return Err(pub_key_err);
        }
    };
    let mut hasher = Sha256::new();

    hasher.update(normalized);

    let hash_result = hasher.finalize();
    let hex_string = hex::encode(hash_result);
    let sliced_hex = &hex_string[24..];

    Ok(sliced_hex.to_string())
}

pub fn convert_bits(data: &Vec<u8>, from_width: u32, to_width: u32, pad: bool) -> Option<Vec<u8>> {
    let mut acc: u32 = 0;
    let mut bits: u32 = 0;
    let mut ret = Vec::new();
    let maxv = (1 << to_width) - 1;

    assert!(from_width < u32::MAX);
    assert!(to_width < u32::MAX);

    for value in data {
        if (*value as u32) >> from_width != 0 {
            return None;
        }

        acc = (acc << from_width) | (*value as u32);
        bits += from_width;

        while bits >= to_width {
            bits -= to_width;
            ret.push(((acc >> bits) & maxv) as u8);
        }
    }

    if pad {
        if bits > 0 {
            ret.push(((acc << (to_width - bits)) & maxv) as u8);
        }
    } else if bits >= from_width || (acc << (to_width - bits)) & maxv != 0 {
        return None;
    }

    Some(ret)
}

pub fn from_bech32_address(address: &str) -> Option<Vec<u8>> {
    let (hrp, data) = match decode(address) {
        Some(addr) => addr,
        None => return None,
    };

    if hrp != HRP {
        return None;
    }

    let buf = match convert_bits(&data, 5, 8, false) {
        Some(buf) => buf,
        None => return None,
    };

    Some(buf)
}

#[test]
fn test_polymod() {
    let bytes: [u8; 16] = [
        65, 29, 177, 250, 15, 49, 136, 8, 34, 192, 119, 116, 123, 146, 130, 62,
    ];
    let res = polymod(&bytes);

    assert_eq!(98216235, res);
}

#[test]
fn test_addr_from_pub_key() {
    let public_key = "0x0308518cf944ece57f0bedc155deb093e1fb8f73aadbd025687a0409cae9ed19b1";
    let addr = get_address_from_public_key(public_key).unwrap();

    assert_eq!(addr, "8885906da076a450138ff794796530a34b958b91");
}

#[test]
fn test_hrp_expand() {
    let test_str = "test";
    let res = hrp_expand(test_str);
    let should: Vec<u8> = vec![3, 3, 3, 3, 0, 20, 5, 19, 20];

    assert_eq!(should, res);
}

#[test]
fn test_create_checksum() {
    let hrp = "test";
    let data: Vec<u8> = vec![255, 64, 0, 0, 0, 2];
    let res = create_checksum(hrp, &data);
    let should: Vec<u8> = vec![2, 14, 10, 20, 25, 19];

    assert_eq!(res, should);
}

#[test]
fn test_encode() {
    let hrp = "test";
    let data = vec![128, 0, 64, 32];
    let res = encode(hrp, &data);
    let should = "test1qep0uve";

    assert_eq!(should, res);
}

#[test]
fn test_gen_limited_vec() {
    let start = 200;
    let end = 500;
    let limit = 20;
    let result = gen_limited_vec(start, end, limit);
    let should_be = vec![
        200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217,
        218, 219,
    ];

    assert_eq!(result, should_be);
}

#[test]
fn test_convert_bits() {
    let byte_vec = hex::decode("7793a8e8c09d189d4d421ce5bc5b3674656c5ac1").unwrap();
    let addr_bz = convert_bits(&byte_vec, 8, 5, true).unwrap();
    let shoud = "0e1e091a111a060013140c091a130a020313121b181619160e11121618161601";

    assert_eq!(hex::encode(addr_bz), shoud);
}

#[test]
fn test_decode() {
    let bech32 = "zil1w7f636xqn5vf6n2zrnjmckekw3jkckkpyrd6z8";
    let (hrp, data) = decode(bech32).unwrap();

    assert_eq!(hrp, "zil");
    assert_eq!(
        hex::encode(data),
        "0e1e091a111a060013140c091a130a020313121b181619160e11121618161601"
    );
}

#[test]
fn test_from_bech32_address() {
    let bech32 = "zil1w7f636xqn5vf6n2zrnjmckekw3jkckkpyrd6z8";
    let base16_buff = from_bech32_address(bech32).unwrap();
    let base16 = hex::encode(base16_buff);

    assert_eq!(base16, "7793a8e8c09d189d4d421ce5bc5b3674656c5ac1");
}

```

`data-rs/src/utils/mod.rs`:

```rs
pub mod crypto;
pub mod zilliqa;

```

`data-rs/src/utils/zilliqa.rs`:

```rs
use crate::config::zilliqa::PROVIDERS;
use log::{error, warn};
use reqwest::header::{HeaderMap, HeaderValue, CONTENT_TYPE};
use reqwest::{Client, Error as ReqwestError};
use serde::de::DeserializeOwned;
use serde::{Deserialize, Serialize};
use serde_json::{from_str, Map, Value};
use std::io::{Error, ErrorKind};
use thiserror::Error;

const MAX_BATCH_SIZE: usize = 2;

#[derive(Serialize, Debug, Clone)]
pub struct JsonBodyReq {
    pub id: String,
    pub jsonrpc: String,
    pub method: String,
    pub params: Value,
}

#[derive(Deserialize, Debug)]
pub struct JsonBodyRes<T> {
    pub result: Option<T>,
    pub error: Option<Map<String, Value>>,
}

impl<T> JsonBodyRes<T> {
    pub fn get_result(&self) -> Result<&T, ZilliqaError> {
        match (&self.result, &self.error) {
            (Some(result), _) => Ok(result),
            (None, Some(err)) => {
                let err_msg = format!("RPC error: {:?}", err);
                error!("{}", err_msg);
                Err(ZilliqaError::RpcError(err_msg))
            }
            (None, None) => Err(ZilliqaError::EmptyResponse),
        }
    }
}

#[derive(Error, Debug)]
pub enum ZilliqaError {
    #[error("All providers are down or unreachable")]
    AllProvidersDown,

    #[error("RPC returned error: {0}")]
    RpcError(String),

    #[error("Empty response with no result or error")]
    EmptyResponse,

    #[error("Request error: {0}")]
    RequestError(#[from] ReqwestError),

    #[error("JSON parse error: {0}")]
    JsonError(#[from] serde_json::Error),

    #[error("IO error: {0}")]
    IoError(#[from] Error),
}

impl From<ZilliqaError> for Error {
    fn from(err: ZilliqaError) -> Self {
        Error::new(ErrorKind::Other, err.to_string())
    }
}

#[derive(Debug, Clone)]
pub struct Zilliqa {
    providers: Vec<String>,
    client: Client,
}

impl Zilliqa {
    pub fn new() -> Self {
        let providers = PROVIDERS.iter().map(ToString::to_string).collect();

        Zilliqa {
            providers,
            client: Client::new(),
        }
    }

    pub fn from(providers: Vec<String>) -> Self {
        Zilliqa {
            providers,
            client: Client::new(),
        }
    }

    pub fn extend_providers(&mut self, urls: Vec<String>) {
        self.providers.extend(urls);
    }

    pub async fn fetch<T: DeserializeOwned + std::fmt::Debug>(
        &self,
        bodies: Vec<JsonBodyReq>,
    ) -> Result<Vec<JsonBodyRes<T>>, ZilliqaError> {
        if self.providers.is_empty() {
            return Err(ZilliqaError::AllProvidersDown);
        }

        let mut headers = HeaderMap::new();
        headers.insert(CONTENT_TYPE, HeaderValue::from_static("application/json"));

        let mut all_results = Vec::with_capacity(bodies.len());

        for chunk in bodies.chunks(MAX_BATCH_SIZE) {
            let mut provider_success = false;

            for provider in &self.providers {
                let response_result = self
                    .try_fetch_from_provider::<Vec<JsonBodyRes<T>>>(provider, chunk, &headers)
                    .await;

                match response_result {
                    Ok(responses) => {
                        for (i, response) in responses.iter().enumerate() {
                            if let Some(err) = &response.error {
                                let method = chunk.get(i).map_or("unknown", |b| &b.method);
                                error!("RPC error for method {}: {:?}", method, err);
                            }
                        }

                        all_results.extend(responses);
                        provider_success = true;
                        break;
                    }
                    Err(e) => {
                        warn!("Provider {} failed: {}", provider, e);
                        continue;
                    }
                }
            }

            if !provider_success {
                warn!("All providers failed for this batch");
            }
        }

        if all_results.is_empty() {
            return Err(ZilliqaError::AllProvidersDown);
        }

        Ok(all_results)
    }

    async fn try_fetch_from_provider<R: DeserializeOwned>(
        &self,
        provider: &str,
        bodies: &[JsonBodyReq],
        headers: &HeaderMap,
    ) -> Result<R, ZilliqaError> {
        let response = self
            .client
            .post(provider)
            .headers(headers.clone())
            .json(bodies)
            .send()
            .await?;

        let status = response.status();
        if !status.is_success() {
            let status_code = status.as_u16();
            let text = response.text().await?;
            let error_msg = format!("HTTP error {}: {}", status_code, text);
            error!("{}", error_msg);
            return Err(ZilliqaError::RpcError(error_msg));
        }

        let text = response.text().await?;

        match from_str::<R>(&text) {
            Ok(res) => Ok(res),
            Err(e) => {
                error!(
                    "Failed to parse JSON response: {}\nResponse text: {}",
                    e, text
                );
                Err(ZilliqaError::JsonError(e))
            }
        }
    }

    pub fn build_body(&self, method: &str, params: Value) -> JsonBodyReq {
        JsonBodyReq {
            id: "1".to_string(),
            jsonrpc: "2.0".to_string(),
            method: method.to_string(),
            params,
        }
    }

    pub async fn fetch_single<T: DeserializeOwned + std::fmt::Debug>(
        &self,
        method: &str,
        params: Value,
    ) -> Result<JsonBodyRes<T>, ZilliqaError> {
        let body = self.build_body(method, params);
        let results = self.fetch::<T>(vec![body]).await?;
        results
            .into_iter()
            .next()
            .ok_or(ZilliqaError::EmptyResponse)
    }
}

```